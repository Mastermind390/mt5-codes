//+------------------------------------------------------------------+
//|                                                     trending.mq5 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>
CTrade trade;

input int fastMa = 14;
input int slowMa = 30;
input int rsi = 14;
input int ema = 200;
input int rsiOverBought = 70;
input int rsiOverSold = 30;
input int slPoint = 200;
input int tpPoint = 500;
input int breakevenPoint = 100;
input bool activateBreakEven = false;
input double lotsize = 0;
input ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT; 

//input int rsiMa = 20;

int OnInit()
{
   double minLot   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   double finalLot = lotsize;

   // If user enters 0 (or negative), use broker's minimum lot
   if(finalLot <= 0.0)
      finalLot = minLot;

   // If user enters below minimum, adjust to min
   if(finalLot < minLot)
      finalLot = minLot;

   // If user enters above maximum, adjust to max
   if(finalLot > maxLot)
      finalLot = maxLot;

   // Normalize to the broker's lot step
   finalLot = MathFloor(finalLot/lotStep) * lotStep;

   Print("Final Lot Size set to: ", finalLot, 
         " | Min: ", minLot, 
         " | Max: ", maxLot, 
         " | Step: ", lotStep);

   // You can store finalLot in a global variable for trade execution
   GlobalVariableSet("EA_LotSize", finalLot);

   return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//---
     int fastMA = iMA(_Symbol,timeframe,fastMa,0,MODE_SMA,PRICE_CLOSE);
     int slowMA = iMA(_Symbol, timeframe,slowMa,0,MODE_SMA,PRICE_CLOSE);
     int rsiHandle = iRSI(_Symbol,timeframe,rsi,PRICE_CLOSE);
     int EMA200 = iMA(_Symbol, timeframe,ema,0,MODE_EMA,PRICE_CLOSE);
     //int RSIMa = iMA(_Symbol, PERIOD_CURRENT,slowMa,0,MODE_SMA,fastMA);
     
     double fastMaBuffer[], slowMaBuffer[], rsiBuffer[], emaBuffer[];
     
     ArraySetAsSeries(rsiBuffer,true);
     CopyBuffer(fastMA,0,0,3,fastMaBuffer);
     CopyBuffer(slowMA,0,0,3,slowMaBuffer);
     CopyBuffer(EMA200,0,0,3,emaBuffer);
     CopyBuffer(rsiHandle,0,0,1,rsiBuffer);
     
     double closePrice = iClose(_Symbol,timeframe,1);
     
     bool uptrend = closePrice > emaBuffer[1];
     bool downtrend = closePrice < emaBuffer[1];
     
     bool sellSignal = rsiBuffer[0] > rsiOverBought && fastMaBuffer[1] > slowMaBuffer[1];
     bool buySignal = rsiBuffer[0] < rsiOverSold && fastMaBuffer[1] < slowMaBuffer[1];
     
     double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
     
     double tick_size  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
     double stopLevel  = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * point;
     
     double stoploss = slPoint * point;
     double takeProfit = tpPoint * point;
     
     stoploss   = MathMax(stoploss, stopLevel);
     takeProfit = MathMax(takeProfit, stopLevel);
     
     stoploss   = MathRound(stoploss / tick_size) * tick_size;
     takeProfit = MathRound(takeProfit / tick_size) * tick_size;
     
     //double entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
     
     //Print(entryPrice + takeProfit);
     
     //Print(tick_value, " , ", tick_size);
     
     if (activateBreakEven) {
        useBreakEven();
     }
     
     //trailingStop();
     
     if (uptrend) {
      
      if (buySignal && PositionSelect(_Symbol) == false) {
         
         double entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         
         double sl = entryPrice - stoploss;
         double tp = entryPrice + takeProfit;
         
         trade.Buy(lotsize,NULL,0,sl,tp);
         
      }
      
     }
     
     if (downtrend) {
      
      if (sellSignal && PositionSelect(_Symbol) == false) {
         
         double entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         
         double sl = entryPrice + stoploss;
         double tp = entryPrice - takeProfit;
         
         trade.Sell(lotsize,NULL,0,sl,tp);
         
      }
      
     }
     
  }
//+------------------------------------------------------------------+


void useBreakEven() {

   int positionTotal = PositionsTotal();
   
   for (int i = 0; i < positionTotal; i++) {
   
      string symbol = PositionGetSymbol(i);
      
      if (!PositionSelect(symbol)) continue;
      
      double positionSl = PositionGetDouble(POSITION_SL);
         
      double positionTp = PositionGetDouble(POSITION_TP);
         
      double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
         
      double newslPoint = breakevenPoint * point;
         
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         
      double minMove = breakevenPoint * point;
         
      double lastClosePrice = iClose(symbol,timeframe,1);
         
      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
          
      double price  = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);


         // breakeven 
      if(type == POSITION_TYPE_BUY) {
         
       if ((price - entryPrice) >= minMove && (positionSl < entryPrice || positionSl == 0)) {
            
         Print("BUY break even");
            
         trade.PositionModify(symbol,entryPrice,positionTp);
            }
      } else if (type == POSITION_TYPE_SELL) { 
      
         if ((entryPrice - price) >= minMove && (positionSl > entryPrice || positionSl == 0))
         
            Print("SELL break even");
            
            trade.PositionModify(symbol,entryPrice,positionTp);
         }  
         
         
         
         //Print(breakeven >= lastClosePrice);
         //Print(entryPrice, " , ", breakeven);
         //Print(type);
   
   }

}
